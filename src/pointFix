import numpy as np
import matplotlib.pyplot as plt
from pygame import Vector3
from neurovec3D import NeuroVector3D
import matplotlib as mpl
from mpl_toolkits.mplot3d import Axes3D
from math import acos



class pointFixe:

    
    def __init__(self, res, type):
        
        self.type = type
        if self.type == 'r': #rectiligne
            self.proie = Vector3(15, 0, -50)
            
        elif self.type == 'h': #helicoidale
            self.z = np.linspace(-2*np.pi, 2*np.pi, 10000)
            self.x = np.cos(self.z)
            self.y = np.sin(self.z)
            self.proie = Vector3(self.x[0], self.y[0], self.z[0])
    
            
        self.res = res
        self.p0 = Vector3(0, 0, 0)
        self.pred = Vector3(0, 0, 0)

        self.n_p0 = NeuroVector3D.fromCartesianVector(self.p0.x, self.p0.y, self.p0.z, self.res)

        self._lambda = 0
     
        self.a_pred = [self.pred]
        self.a_proie = [self.proie]

        self.t = 1
        self.a_a = []
        self.erreur = 0
        
        self.v = []

    def update(self):

        """n_pred = NeuroVector3D.fromCartesianVector(self.pred.x, self.pred.y, self.pred.z, self.res)
        n_proie = NeuroVector3D.fromCartesianVector(self.proie.x, self.proie.y, self.proie.z, self.res)
        """
        ref = (self.pred - self.p0)
        rp =  (self.proie - self.pred)

        n_ref = NeuroVector3D.fromCartesianVector(ref.x, ref.y, ref.z, self.res) * (self._lambda - 1)
        n_rp  = NeuroVector3D.fromCartesianVector(rp.x, rp.y, rp.z, self.res) * self._lambda
        
        dt = n_ref + n_rp

        dt_c = Vector3(dt.extractCartesianParameters())

        self.v.append(dt_c.length())

        self.pred = self.pred + dt_c

        if self.t>1 and self.t % 4 == 0:
            # a = (self.proie-self.pred).angle_to(self.pred - self.p0)
            refp = self.pred - self.p0
            rp   = self.proie- self.pred
            cosa = refp.dot(rp) / (refp.length() * rp.length())
            a    = acos(cosa if cosa <= 1 else 1)

            self.a_a.append(cosa)
            self.erreur += np.degrees(a)
        
        dist = (self.pred - self.proie).length()

        if self.type == 'r':
            self.proie = self.proie + Vector3(0, .01, .01)
        elif self.type == 'h':
            self.proie = Vector3(self.x[self.t], self.y[self.t], self.z[self.t])

        self._lambda += 0.0054 * (1 - self._lambda)

        self.a_pred.append(self.pred)
        self.a_proie.append(self.proie)

        self.t += 1

        return dist
        

    def draw(self, g1, g2, p):

        mpl.rcParams['legend.fontsize'] = 10
        fig = plt.figure(figsize=(8,8))
        ax = fig.add_subplot(111, projection='3d')

        ax.scatter(p[0], p[1], p[2], label = 'point fixe ', color = 'g')
        ax.scatter(g1[0][0], g1[1][0], g1[2][0])
    
        ax.plot(g1[0], g1[1], g1[2], label='proie')
        ax.plot(g2[0], g2[1], g2[2], label='predateur ')
       
        ax.legend()

        plt.show()

c = pointFixe(4, 'r')

for i in range(int(1e5)):
    if c.update() < .1:
        break

x = [i[0] for i in c.a_proie]
y = [i[1] for i in c.a_proie]
z = [i[2] for i in c.a_proie]

x1 = [i[0] for i in c.a_pred]
y1 = [i[1] for i in c.a_pred]
z1 = [i[2] for i in c.a_pred]

c.draw([x,y,z], [x1,y1,z1], c.p0)

print("erreur :", c.erreur/len(c.a_a))

print(c.t)

plt.plot(c.a_a)
plt.show()